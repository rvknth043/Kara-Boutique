diff a/backend/src/server.ts b/backend/src/server.ts	(rejected hunks)
@@ -24,52 +24,63 @@ import reviewRoutes from './routes/review.routes';
 import adminRoutes from './routes/admin.routes';
 import analyticsRoutes from './routes/analytics.routes';
 import exchangeRoutes from './routes/exchange.routes';
 import addressRoutes from './routes/address.routes';
 import couponRoutes from './routes/coupon.routes';
 import invoiceRoutes from './routes/invoice.routes';
 import uploadRoutes from './routes/upload.routes';
 import recommendationRoutes from './routes/recommendation.routes';
 import emailVerificationRoutes from './routes/emailVerification.routes';
 
 // Import middleware
 import { errorHandler } from './middleware/errorHandler';
 import { rateLimiter } from './middleware/rateLimiter';
 import { logger } from './utils/logger';
 
 // Initialize Express app
 const app: Application = express();
 const httpServer = http.createServer(app);
 const PORT = process.env.PORT || 5000;
 
 // Initialize Socket.io
 const socketService = initializeSocket(httpServer);
 
 // Middleware
 app.use(helmet()); // Security headers
+const allowedOrigins = (process.env.FRONTEND_URL || 'http://localhost:3000,http://127.0.0.1:3000')
+  .split(',')
+  .map((origin) => origin.trim())
+  .filter(Boolean);
+
 app.use(cors({
-  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
+  origin: (origin, callback) => {
+    if (!origin || allowedOrigins.includes(origin)) {
+      return callback(null, true);
+    }
+
+    return callback(new Error(`CORS blocked for origin: ${origin}`));
+  },
   credentials: true,
 }));
 app.use(express.json({ limit: '10mb' }));
 app.use(express.urlencoded({ extended: true, limit: '10mb' }));
 
 // Apply rate limiting
 app.use(rateLimiter);
 
 // Request logging
 app.use((req: Request, res: Response, next: NextFunction) => {
   logger.info(`${req.method} ${req.path}`, {
     ip: req.ip,
     userAgent: req.get('user-agent'),
   });
   next();
 });
 
 // Health check endpoint
 app.get('/health', (req: Request, res: Response) => {
   res.json({
     status: 'OK',
     timestamp: new Date().toISOString(),
     uptime: process.uptime(),
   });
 });
